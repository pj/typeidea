/**
* **GENERATED CODE DO NOT EDIT!**
*/
<% types.forEach(function (type) { -%>
/*
* <%= type.name %>
* <%= type.description %>
* Change Log:
  <% type.changeLog.forEach(function (log, index) { -%>
* <%= index + 1 %>. <%= log %>
  <%_ }) -%>
*/
<% }) %>
<% types.forEach(function (type) { %>
  <% type.versions.forEach(function (version) { %>
    <% Object.keys(version.fields).forEach(function (key) { -%>
      <% var field = version.fields[key]; %>
      <% if (field.referenceType) { %>
        // import * as <%= field.referenceType %> from './<%= field.referenceType %>';
      <% } %>
    <% }) %>
  <% }) %>
<% }) %>

<% types.forEach(function (type) { %>
  <% type.versions.forEach(function (version, index) { %>
    <%- include('typescript_class', {className: type.name + '_H' + version.hash, version: version}); %>

    export type <%= type.name %>_V<%= index %> = <%= type.name %>_H<%= version.hash %>;
  <% }) %>
  <% if (type.latest !== null) { %>
    <% include('typescript_class', {className: 'Latest', version: type.latest}); %>
  <% } %>

  export class <%= type.name %> {
    static deserialize(message: any):
      <%= type.versions.map((version, index) => type.name + '_V' + index).join(' | ') %>
    {
      if (message.version === null || message.version === undefined) {
        throw new Error(`version not present: ${message}`);
      }
      switch (message.version) {
      <% type.versions.forEach(function (version, index) { %>
        case "<%= type.name %>_V<%= index %>":
        case "<%= type.name %>_H<%= version.hash %>":
          return (
            new <%= type.name %>_H<%= version.hash %>(
              <%= index %>,
              "<%= version.hash %>",
              <%=
                Object.keys(version.fields).map(function (key) {
                  const field = version.fields[key];
                  return `message.${field.name}`;
                }).join(', ')
              %>
            )
          );
      <% }) %>
      default:
         throw new Error(`Unknown version error or version not present: ${message}`);
      }
    }

    static serialize(
      message: <%= type.versions.map((version, index) => type.name + '_V' + index).join(' | ') %>
    ): string {
      if (message.version === null || message.version === undefined) {
        throw new Error(`version not present: ${message}`);
      }
      return JSON.stringify(message);
    }
  }
<% }) %>

